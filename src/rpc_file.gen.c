
/*
 * Automatically generated from src/rpc_file.rpc
 * by event_rpcgen.py/0.1.  DO NOT EDIT THIS FILE.
 */

#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <event2/event-config.h>
#include <event2/event.h>
#include <event2/buffer.h>
#include <event2/tag.h>

#if defined(EVENT__HAVE___func__)
# ifndef __func__
#  define __func__ __func__
# endif
#elif defined(EVENT__HAVE___FUNCTION__)
# define __func__ __FUNCTION__
#else
# define __func__ __FILE__
#endif


#include "rpc_file.gen.h"

void event_warn(const char *fmt, ...);
void event_warnx(const char *fmt, ...);

/*
 * Implementation of BarnQueryRequest
 */

static struct BarnQueryRequest_access_ BarnQueryRequest_base__ = {
  BarnQueryRequest_item_name_assign,
  BarnQueryRequest_item_name_get,
};

struct BarnQueryRequest *
BarnQueryRequest_new(void)
{
  return BarnQueryRequest_new_with_arg(NULL);
}

struct BarnQueryRequest *
BarnQueryRequest_new_with_arg(void *unused)
{
  struct BarnQueryRequest *tmp;
  if ((tmp = malloc(sizeof(struct BarnQueryRequest))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &BarnQueryRequest_base__;

  tmp->item_name_data = NULL;
  tmp->item_name_set = 0;

  return (tmp);
}


int
BarnQueryRequest_item_name_assign(struct BarnQueryRequest *msg,
    const char * value)
{
  if (msg->item_name_data != NULL)
    free(msg->item_name_data);
  if ((msg->item_name_data = strdup(value)) == NULL)
    return (-1);
  msg->item_name_set = 1;
  return (0);
}

int
BarnQueryRequest_item_name_get(struct BarnQueryRequest *msg, char * *value)
{
  if (msg->item_name_set != 1)
    return (-1);
  *value = msg->item_name_data;
  return (0);
}

void
BarnQueryRequest_clear(struct BarnQueryRequest *tmp)
{
  if (tmp->item_name_set == 1) {
    free(tmp->item_name_data);
    tmp->item_name_data = NULL;
    tmp->item_name_set = 0;
  }
}

void
BarnQueryRequest_free(struct BarnQueryRequest *tmp)
{
  if (tmp->item_name_data != NULL)
      free (tmp->item_name_data);
  free(tmp);
}

void
BarnQueryRequest_marshal(struct evbuffer *evbuf, const struct BarnQueryRequest *tmp) {
  if (tmp->item_name_set) {
    evtag_marshal_string(evbuf, BARNQUERYREQUEST_ITEM_NAME, tmp->item_name_data);
  }
}

int
BarnQueryRequest_unmarshal(struct BarnQueryRequest *tmp, struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case BARNQUERYREQUEST_ITEM_NAME:
        if (tmp->item_name_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, BARNQUERYREQUEST_ITEM_NAME, &tmp->item_name_data) == -1) {
          event_warnx("%s: failed to unmarshal item_name", __func__);
          return (-1);
        }
        tmp->item_name_set = 1;
        break;
      default:
        return -1;
    }
  }

  if (BarnQueryRequest_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
BarnQueryRequest_complete(struct BarnQueryRequest *msg)
{
  return (0);
}

int
evtag_unmarshal_BarnQueryRequest(struct evbuffer *evbuf, ev_uint32_t need_tag,
  struct BarnQueryRequest *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (BarnQueryRequest_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_BarnQueryRequest(struct evbuffer *evbuf, ev_uint32_t tag,
    const struct BarnQueryRequest *msg)
{
  struct evbuffer *buf_ = evbuffer_new();
  assert(buf_ != NULL);
  BarnQueryRequest_marshal(buf_, msg);
  evtag_marshal_buffer(evbuf, tag, buf_);
  evbuffer_free(buf_);
}

/*
 * Implementation of BarnQueryReply
 */

static struct BarnQueryReply_access_ BarnQueryReply_base__ = {
  BarnQueryReply_items_assign,
  BarnQueryReply_items_get,
};

struct BarnQueryReply *
BarnQueryReply_new(void)
{
  return BarnQueryReply_new_with_arg(NULL);
}

struct BarnQueryReply *
BarnQueryReply_new_with_arg(void *unused)
{
  struct BarnQueryReply *tmp;
  if ((tmp = malloc(sizeof(struct BarnQueryReply))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &BarnQueryReply_base__;

  tmp->items_data = 0;
  tmp->items_set = 0;

  return (tmp);
}


int
BarnQueryReply_items_assign(struct BarnQueryReply *msg, const ev_uint32_t value)
{
  msg->items_set = 1;
  msg->items_data = value;
  return (0);
}

int
BarnQueryReply_items_get(struct BarnQueryReply *msg, ev_uint32_t *value)
{
  if (msg->items_set != 1)
    return (-1);
  *value = msg->items_data;
  return (0);
}

void
BarnQueryReply_clear(struct BarnQueryReply *tmp)
{
  tmp->items_set = 0;
}

void
BarnQueryReply_free(struct BarnQueryReply *tmp)
{
  free(tmp);
}

void
BarnQueryReply_marshal(struct evbuffer *evbuf, const struct BarnQueryReply *tmp) {
  evtag_marshal_int(evbuf, BARNQUERYREPLY_ITEMS, tmp->items_data);
}

int
BarnQueryReply_unmarshal(struct BarnQueryReply *tmp, struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case BARNQUERYREPLY_ITEMS:
        if (tmp->items_set)
          return (-1);
        if (evtag_unmarshal_int(evbuf, BARNQUERYREPLY_ITEMS, &tmp->items_data) == -1) {
          event_warnx("%s: failed to unmarshal items", __func__);
          return (-1);
        }
        tmp->items_set = 1;
        break;
      default:
        return -1;
    }
  }

  if (BarnQueryReply_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
BarnQueryReply_complete(struct BarnQueryReply *msg)
{
  if (!msg->items_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_BarnQueryReply(struct evbuffer *evbuf, ev_uint32_t need_tag,
  struct BarnQueryReply *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (BarnQueryReply_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_BarnQueryReply(struct evbuffer *evbuf, ev_uint32_t tag,
    const struct BarnQueryReply *msg)
{
  struct evbuffer *buf_ = evbuffer_new();
  assert(buf_ != NULL);
  BarnQueryReply_marshal(buf_, msg);
  evtag_marshal_buffer(evbuf, tag, buf_);
  evbuffer_free(buf_);
}

/*
 * Implementation of SiloQueryRequest
 */

static struct SiloQueryRequest_access_ SiloQueryRequest_base__ = {
  SiloQueryRequest_item_name_assign,
  SiloQueryRequest_item_name_get,
};

struct SiloQueryRequest *
SiloQueryRequest_new(void)
{
  return SiloQueryRequest_new_with_arg(NULL);
}

struct SiloQueryRequest *
SiloQueryRequest_new_with_arg(void *unused)
{
  struct SiloQueryRequest *tmp;
  if ((tmp = malloc(sizeof(struct SiloQueryRequest))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &SiloQueryRequest_base__;

  tmp->item_name_data = NULL;
  tmp->item_name_set = 0;

  return (tmp);
}


int
SiloQueryRequest_item_name_assign(struct SiloQueryRequest *msg,
    const char * value)
{
  if (msg->item_name_data != NULL)
    free(msg->item_name_data);
  if ((msg->item_name_data = strdup(value)) == NULL)
    return (-1);
  msg->item_name_set = 1;
  return (0);
}

int
SiloQueryRequest_item_name_get(struct SiloQueryRequest *msg, char * *value)
{
  if (msg->item_name_set != 1)
    return (-1);
  *value = msg->item_name_data;
  return (0);
}

void
SiloQueryRequest_clear(struct SiloQueryRequest *tmp)
{
  if (tmp->item_name_set == 1) {
    free(tmp->item_name_data);
    tmp->item_name_data = NULL;
    tmp->item_name_set = 0;
  }
}

void
SiloQueryRequest_free(struct SiloQueryRequest *tmp)
{
  if (tmp->item_name_data != NULL)
      free (tmp->item_name_data);
  free(tmp);
}

void
SiloQueryRequest_marshal(struct evbuffer *evbuf, const struct SiloQueryRequest *tmp) {
  if (tmp->item_name_set) {
    evtag_marshal_string(evbuf, SILOQUERYREQUEST_ITEM_NAME, tmp->item_name_data);
  }
}

int
SiloQueryRequest_unmarshal(struct SiloQueryRequest *tmp, struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case SILOQUERYREQUEST_ITEM_NAME:
        if (tmp->item_name_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, SILOQUERYREQUEST_ITEM_NAME, &tmp->item_name_data) == -1) {
          event_warnx("%s: failed to unmarshal item_name", __func__);
          return (-1);
        }
        tmp->item_name_set = 1;
        break;
      default:
        return -1;
    }
  }

  if (SiloQueryRequest_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
SiloQueryRequest_complete(struct SiloQueryRequest *msg)
{
  return (0);
}

int
evtag_unmarshal_SiloQueryRequest(struct evbuffer *evbuf, ev_uint32_t need_tag,
  struct SiloQueryRequest *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (SiloQueryRequest_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_SiloQueryRequest(struct evbuffer *evbuf, ev_uint32_t tag,
    const struct SiloQueryRequest *msg)
{
  struct evbuffer *buf_ = evbuffer_new();
  assert(buf_ != NULL);
  SiloQueryRequest_marshal(buf_, msg);
  evtag_marshal_buffer(evbuf, tag, buf_);
  evbuffer_free(buf_);
}

/*
 * Implementation of SiloQueryReply
 */

static struct SiloQueryReply_access_ SiloQueryReply_base__ = {
  SiloQueryReply_items_assign,
  SiloQueryReply_items_get,
};

struct SiloQueryReply *
SiloQueryReply_new(void)
{
  return SiloQueryReply_new_with_arg(NULL);
}

struct SiloQueryReply *
SiloQueryReply_new_with_arg(void *unused)
{
  struct SiloQueryReply *tmp;
  if ((tmp = malloc(sizeof(struct SiloQueryReply))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->base = &SiloQueryReply_base__;

  tmp->items_data = 0;
  tmp->items_set = 0;

  return (tmp);
}


int
SiloQueryReply_items_assign(struct SiloQueryReply *msg, const ev_uint32_t value)
{
  msg->items_set = 1;
  msg->items_data = value;
  return (0);
}

int
SiloQueryReply_items_get(struct SiloQueryReply *msg, ev_uint32_t *value)
{
  if (msg->items_set != 1)
    return (-1);
  *value = msg->items_data;
  return (0);
}

void
SiloQueryReply_clear(struct SiloQueryReply *tmp)
{
  tmp->items_set = 0;
}

void
SiloQueryReply_free(struct SiloQueryReply *tmp)
{
  free(tmp);
}

void
SiloQueryReply_marshal(struct evbuffer *evbuf, const struct SiloQueryReply *tmp) {
  evtag_marshal_int(evbuf, SILOQUERYREPLY_ITEMS, tmp->items_data);
}

int
SiloQueryReply_unmarshal(struct SiloQueryReply *tmp, struct evbuffer *evbuf)
{
  ev_uint32_t tag;
  while (evbuffer_get_length(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case SILOQUERYREPLY_ITEMS:
        if (tmp->items_set)
          return (-1);
        if (evtag_unmarshal_int(evbuf, SILOQUERYREPLY_ITEMS, &tmp->items_data) == -1) {
          event_warnx("%s: failed to unmarshal items", __func__);
          return (-1);
        }
        tmp->items_set = 1;
        break;
      default:
        return -1;
    }
  }

  if (SiloQueryReply_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
SiloQueryReply_complete(struct SiloQueryReply *msg)
{
  if (!msg->items_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_SiloQueryReply(struct evbuffer *evbuf, ev_uint32_t need_tag,
  struct SiloQueryReply *msg)
{
  ev_uint32_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (SiloQueryReply_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_SiloQueryReply(struct evbuffer *evbuf, ev_uint32_t tag,
    const struct SiloQueryReply *msg)
{
  struct evbuffer *buf_ = evbuffer_new();
  assert(buf_ != NULL);
  SiloQueryReply_marshal(buf_, msg);
  evtag_marshal_buffer(evbuf, tag, buf_);
  evbuffer_free(buf_);
}

